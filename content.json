{"pages":[{"title":"关于我","text":"关俊，Android 开发。 记录 Android，记录生活，记录自己。 好好努力，好好生活。","link":"/about/index.html"},{"title":"世界与我","text":"","link":"/world/index.html"}],"posts":[{"title":"Handler 的使用和解析","text":"Handler 常用使用场景在 Activity 中定义一个 Handler 1234567891011121314private val mHandler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { when(msg.what) { CODE_GET_USER_INFO -&gt; { val user = msg.obj as User textViewName.text = user.name textViewSite.text = user.site imageViewIcon.load(user.icon){ transformations(CircleCropTransformation()) } } } }} 在子线程获取到数据之后通过 Handler 将数据传到 UI 线程进行处理 12345678910111213Thread { val request = Request.Builder() .url(\"http://10.0.2.2:8000/user\") .build() val response = OkHttpClient().newCall(request).execute() val result = response.body?.string() val user = Gson().fromJson(result, User::class.java) Message.obtain().also { it.what = CODE_GET_USER_INFO it.obj = user mHandler.sendMessage(it) }}.start() 打开 Handler 源文件，可以看到这样的注释 There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 简单概述一下，Handler 两个用途：（1）在未来某个时间点执行事件 （2）跨线程执行事件 源码分析Handler 构造函数12345678910111213141516171819public Handler(@NonNull Looper looper) { this(looper, null, false);}final Looper mLooper;final MessageQueue mQueue;final Callback mCallback;final boolean mAsynchronous;public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;}public interface Callback { boolean handleMessage(@NonNull Message msg);} 在 Handler 的构造函数中初始化了两个重要的成员变量：mLooper 和 mQueue 我们传人的参数是 Looper.getMainLooper()，代码如下 1234567private static Looper sMainLooper;public static Looper getMainLooper() { synchronized (Looper.class) { return sMainLooper; }} Looper 中的 sMainLooper 又是在哪里初始化的呢？我们看 ActivityThread 这个类中的 main 函数 1234567public static void main(String[] args) { ... Looper.prepareMainLooper(); ... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");} prepareMainLooper() Looper 的 prepareMainLooper 函数以及后续相关函数调用 12345678910111213public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); }}public static Looper myLooper() { return sThreadLocal.get();} 实际上调用了 prepare 函数。 12345678static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed));} 1234567final MessageQueue mQueue;final Thread mThread; private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} 至此，我们可以确定，在 ActivityThread 执行的时候，初始化了 Looper，并且初始化了 Looper 中两个成员变量：消息队列 和 当前线程对象。 值得注意的是： 一个线程只能创建一个 Looper，也就是说线程和 Looper 是一一对应的，且它俩是有一定的绑定关系的 Looper 中有一个 ThreadLocal 数据结构，用来存储线程和 Looper，维系两者的绑定关系 我们看一下 ThreadLocal 的相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();}public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);}void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);}ThreadLocalMap getMap(Thread t) { return t.threadLocals;}static class ThreadLocalMap { static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } ... private Entry[] table; ...} 可以看出，ThreadLocal 中有个 ThreadLocalMap 类，它其实跟 Map 没啥关系。ThreadLocalMap 有个继承于 WeakReference 的内部类 Entry 用来存储 Looper，而 ThreadLocalMap 是赋值给 Thread 的成员变量 threadLocals 的。 那么也就是通过这种方式实现了一个线程和一个 Looper 的绑定。 Looper.loop()初始化的动作做完之后，执行了 Looper.loop() 123456789101112131415161718public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } if (me.mInLoop) { Slog.w(TAG, \"Loop again would have the queued messages be executed\" + \" before this one completed.\"); } me.mInLoop = true; ... for (;;) { if (!loopOnce(me, ident, thresholdOverride)) { return; } }} 12345678910private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) { Message msg = me.mQueue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return false; } ... msg.target.dispatchMessage(msg); ...} 我们可以看到 loop 函数中执行了一个死循环，不断的执行 loopOnce 函数。 在 loopOnce 函数中我们需要注意 2 点： Message msg = me.mQueue.next(); msg.target.dispatchMessage(msg); mQueue.next()注意看 next 后面的的注释 might block，这个函数是会阻塞的。 123456789101112131415161718192021222324252627282930313233343536Message next() { ... for (;;) { ... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { ... } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; msg.markInUse(); return msg; } } ... } ... }} 这里可以看到，next 其实也是执行了一个死循环，不断的取出下一个 Message ，判断其出发时间是否符合，然后将其返回。倘若没有 Message ，nativePollOnce 会阻塞该函数，直到新的 Message 进入 MessageQueue。 msg.target.dispatchMessage(msg)取到符合触发时间的消息后，会执行该函数。查看 Message 类我们会发现，它有一个成员变量 1Handler target; 然后执行了 Handler 的 dispatchMessage 函数，传入了当前触发的 Message。 有 2 点需要理解： Message 中的 target 是什么时候初始化的 Handler 中的 dispatchMessage 做了什么 回头看最开始简单的使用案例，我们执行了 mHandler.sendMessage(it) 将消息进行发送，进入该函数。 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(@NonNull Message msg) { return sendMessageDelayed(msg, 0);}public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);}public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);}private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);} 最终调用了 enqueueMessage 将当前 Handler 对象赋值给此次 Message 的 target，并将消息添加到消息队列。 需要注意的是 MessageQueue 中的 enqueueMessage 函数中，除了将 Message 添加到消息队列，还在某些条件下执行了一个函数 nativeWake()，这个函数就是对应上文中 nativePollOnce() 的，将阻塞唤醒。 最后我们再看 dispatchMessage 12345678910111213141516public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }}private static void handleCallback(Message message) { message.callback.run();} 其实是将消息进行分发消费。这里主要有 3 种消费方式 Message 中的 callback（其实是一个 Runnable ） 通过 run 进行处理 Handler 中的 Callback 通过 handleMessage 进行处理 直接通过 Handler 中的 handleMessage 进行处理 这也对应 Handler 的三种使用方式。 Handler 的三种使用方式 handler.post(Runnable r) 123456789public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0);}private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m;} Handler(Looper looper, Callback callback) 123public Handler(@NonNull Looper looper, @Nullable Callback callback) { this(looper, callback, false);} 文中常用使用场景 1234private val mHandler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { }} 总结关于 Handler 大致可以分为 3 个阶段去理解 初始化阶段 在创建 Handler 对象的同时，会初始化 Looper 和 Looper 中的 MessageQueue。 Looper 的初始化包括对象创建和 loop() 调用。 Looper 的初始化涉及到 Handler 所工作的线程，井且会将 Looper 对象存储在 Threadlocal 中，再赋值给该线程的成员变量。这样线程和 Looper 就建立了绑定关系，且一个线程最多只能创建一个Looper，初始化多次会拋出异常。值得注意的是在 UI 线程是不需要调用 Looper.prepare() 去初始化的，因为在ActivityThread 的 main 函数，也就是APP进程启动入口里面，已经执行了 Looper.prepareMainLooper() 和 Looper.loop()。 loop() 调用其实就是执行了一个死循环，然后从 MessageQueue 中取出 Message， 取到了就发给 Handler 去处理，取不到就阻塞。 消息发送 通过 Handler 将 Message 加入 MessageQueue。 这里首先会将 Handler 与 Message 进行绑定，以便后续 Message 取出后交给Handler 进行处理 按照 Message 的执行时间将其插入到 MessageQueue 中 消息分发 在loop()循环中检查到符合执行时间的 Message 后，这里对应 Handler 的不同构造方法和消息发送方式有 3种分发情况。 handler.post(Runnable n)，优先判断 Message 中是否有 Runnable对象，有的话执行其 run 方法 Handler(Looper looper, Callback callback)，其次再判断是否在创建 Handler 的时候传入了 Callback，如果有，执行其 handleMessage 方法 上述两种都不满足的话，执行 Handler 自身的 handleMessage 方法","link":"/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"},{"title":"Hexo + GitHub 构建博客","text":"1. 下载安装 NodeNode官网，一步步安装即可 2. 安装 Git3. 申请 GitHub（用户名为 username ），配置 SSH Keys创建仓库，名字固定：username.github.io 4. 安装 HEXO打开Git Bash, 执行 1sudo npm install -g hexo 如果不行，执行 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后安装，执行 1npm install hexo -g 5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口执行 1hexo init 再执行 1hexo generate （hexo g 也可以） 6. 启动 HEXO执行 1hexo server 浏览器输入 http://localhost:4000 即可打开 7. 修改 blog 下 _config.yml最下方修改为 12345type: gitrepository: https://github.com/username/username.github.iobranch: master-其他配置自主修改 然后 执行 1npm install hexo-deployer-git --save 执行 1hexo deploy 现在查看 github 仓库，你会发现已经有很多文件了在浏览器打开 https://username.github.io/ 即可访问 8. 常用命令部署 123hexo cleanhexo generatehexo deploy 其他 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 case:创建一片博文 123451. hexo new \"title\"2. \\blog\\source\\_posts下会生成title.md文件，用MD编辑器打开，编写内容3. hexo generate4. hexo deploy5. 完成，重新访问blog即可看到刚才编辑的文章","link":"/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"Hexo修改主题","text":"1. 挑选自己喜欢的主题进入 hexo主题网站，挑选自己喜欢的主题，点击预览图进入效果展示模版网站，点击主题名称进入主题 GitHub 仓库。 2. 下载主题执行clone命令，下载到对应的文件夹内。一般主题仓库都有相关说明。 1git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 如果该项目有其他依赖库，需要一并下载。 12npm install ejs --save-dnpm install hexo-renderer-sass --save 3. 修改配置打开博客源文件根目录下 _config.yml，修改如下： 1theme: minos 其他配置可以参考主题仓库中描述进行修改。 4. 保存和部署1hexo g -d","link":"/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"},{"title":"2022 Android 面试准备","text":"ActivitysingleTask：单例，taskAffinity：指定 Activity 要压入的 task singleInstance：单例且独立 task allowTaskReparenting 赋予 Activity 在各个 Task 中间转移的特性 Activity 的 onSaveInstance 方法何时调用？它跟onPause、onStop的调用顺序如何？ Binder 传输限制通常 1 M，不同厂商不同版本会有区别。 非必须的字段添加 transient 禁止序列化 转 json 传输 startActivity的具体过程 执行到 Instrumentation#execStartActivity 通过 ActivityTaskManager.getService() 获取 ATMS（Binder）代理，执行其 startActivity 在系统启动的时候， 有从 init 到 zygote 到 system_server 的一套流程 构建一个 ActivityStarter ，根据请求参数进行启动 权限检查，处理异常 封装 ActivityRecord，处理更新 task 栈帧信息 判断目标进程是否已存在 已存在：那么目标 ActivityThread 已经启动且 ATMS 是持有其内部 Binder（ApplicationThread）代理的。开启事务，通过 ActivityThread 的 Binder 代理，发送事务执行消息，最终执行 handleLaunchActivity 反射创建 Activity 对象 调用 Activity#attach 构建 PhoneWindow，将 Activity 与其关联，并持有 WindowManagerImpl 的引用 调用 Instrumentation#callActivityOnCreate 执行 Activity 的 onCreate 生命周期 不存在：ATMS 通过 startProcessAsync 发送异步消息通知 AMS 启动进程 这里是通过 PooledLambda 构建了一个 Message，再通过 mH.sendMessage 发送消息，但是我在 mH 中没有看到相关处理逻辑，进入到 PooledLambda 中发现，其实是通过 Message.obtain().setCallback 生成的 Message，所以这里其实是使用的 Message 中的 Runnable x消息分发触发 run 方法从而执行的传入的 ActivityManagerInternal::startProcess 方法，最终由实现了该接口的 AMS 的内部类 LocalService 执行 AMS.LocalService#startProcess -&gt; ProcessList#startProcess -&gt; Zygote 创建进程，执行applicationInit，调用 ActivityThread.main。这里 AMS 将持有 ActivityThread 的 Binder 代理 prepareMainLooper 构建 ActivityThread，执行 attach 方法， 通过 getService 调用 AMS#attachApplication，将 ApplicationThread（Binder）传入 AMS 通过 ApplicationThread 调用 bindApplication 又回到 ActivityThread ActivityThread 中执行 sendMessage(H.BIND_APPLICATION, data)，实际执行 handleBindApplication 构建 Instrumentation 和 Application，Instrumentation#callApplicationOnCreate Looper.loop() AMS 继续执行 Activity 的启动处理 Flag，launchMode，taskAffinity Activity#setContentView的具体过程①PhoneWindow是何时创建的，它的作用是什么？ 创建 Activity 时调用其 attach 方法中创建的，… ②setContentView中传递的资源文件是如何变成View对象的？ LayoutInflater.from(mContext).inflate(resId, contentParent); ③布局文件对应的View对象是添加到哪里的？ DecorView 中的 contentParent 中 ④Activity的布局是何时显示出来的？ 只有执行完 onResume 之后 Activity 中的内容才是屏幕可见状态。onCreate 阶段只是初始化了 Activity 需要显示的内容，而在 onResume 阶段才会将 PhoneWindow 中的 DecorView 真正的绘制到屏幕上。 ⑤ViewRootImpl是何时初始化的？它的作用是什么？ ⑥Choreography了解么？作用是什么？ 初始化阶段 AppCompatDelegateImpl#setContentView 执行 PhoneWindow#getDecorView()，构建 DecorView（FrameLayout），从DecorView 中获取 mContentParent 将 resId 通过 inflate 转化成 View 添加到 mContentParent 中 绘制阶段 执行 ActivityThread#handleResumeActivity，调用 WindowManager.addView 实际调用 WindowManagerGlobal#addView 构建 ViewRootImpl，调用其 setView 方法（将 DecorView 添加到 WMS） requestLayout() - 执行完整的 View 树的渲染操作。调用此方法后 ViewRootImpl 所关联的 View 也执行 measure - layout - draw 操作，确保在 View 被添加到 Window 上显示到屏幕之前，已经完成测量和绘制操作。 checkThread() 检查线程是否合法，需与 ViewRootImpl 一致，即 UI 线程 scheduleTraversals() - 方法中添加了同步屏障，实际执行 performTraversals()，这个方法就是真正的开始 View 绘制流程：measure –&gt; layout –&gt; draw 。 performLayout() measureHierarchy() - performMeasure() - mView.measure() host.layout() – host = mView performDraw() draw(fullRedrawNeeded) mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this) – 硬件加速绘制（GPU） drawSoftware() – 软件绘制（CPU） mView.draw(canvas) surface.unlockCanvasAndPost(canvas) – 将 Canvas 中的内容提交给 SurfaceFlinger 进行合成处理。 调用 mWindowSession.addToDisplayAsUser，mWS = WindowManagerGlobal.getWindowSession() getWindowSession - 通过 ipc 调用 WMS#openSession 获取 Session，调用其 addToDisplayAsUser，将 ViewRootImpl 弱引用存储，整个给到 WMS 实际调用 WMS#addWindow，完成后面的添加动作 设置输入管道，用来接收屏幕触摸事件 ViewRootImpl 中有一个非常重要的对象 Surface，之所以说 ViewRootImpl 的一个核心功能就是负责 UI 渲染，原因就在于在 ViewRootImpl 中会将我们在 draw 方法中绘制的 UI 元素，绑定到这个 Surface 上。如果说 Canvas 是画板，那么 Surface 就是画板上的画纸，Surface 中的内容最终会被传递给底层的 SurfaceFlinger，最终将 Surface 中的内容进行合成并显示的屏幕上。 硬件加速绘制 并不是所有的 2D 绘制操作都支持硬件加速 View 视图被抽象成 RenderNode 节点，View 中的绘制操作都会被抽象成一个个 DrawOp，每个 DrawOp 有对应的 OpenGL 绘制命令。 遍历 View 递归构建 DrawOp，根据 Canvas 将所有的 DrawOp 进行缓存操作。所有的 DrawOp 对应的 OpenGL 命令构建完成之后，就需要使用 RenderProxy 向 RenderThread 发送消息，请求 OpenGL 线程进行渲染。整个渲染过程是通过 GPU 并在不同线程绘制渲染图形，因此整个流程会更加顺畅。 Invalidate 这个方法跟 requestLayout 的区别在于，它不一定会触发 View 的 measure 和 layout 的操作，多数情况下只会执行 draw 操作。 measure 方法中有个强制布局的标志位，只有当这个标志位为 true 才会执行 onMeasure，requestLayout 中会设置，但是 invalidate 不会。 当调用 invalidate 方法时，如果 View 的位置并没有发生改变，则 View 不会触发重新布局的操作。 postInvalidate invalidate 是在 UI 线程调用，postInvalidate 是在非 UI 线程调用。 事件分发，滑动冲突触摸事件通过驱动层 WMS 到达 DecorView 的 dispatchTouchEvent，执行 mWindow.cb.dispatchTouchEvent，这里的 cb 就是 Activity（在 Activity 的 attach 中设置），再从 Activity 的 dispatchTouchEvent 到 PhoneWindow.superDispatchTouchEvent，再到 DecorView.superDispatchTouchEvent 从 ViewGroup#dispatchTouchEvent 开始 判断 ViewGroup 是否拦截（down 事件 或者 TouchTarget 不为空），通过 onInterceptTouchEvent 判断 不拦截，事件分发给子 View 继续处理 前提是 down 事件 遍历子 View，View 坐标范围符合且不在动画状态 dispatchTransformedTouchEvent 将事件分发给 View# dispatchTouchEvent ，如果 View 消费事件，赋值给 TouchTarget 如果有子 View 消费事件，将后续事件直接交其处理 这里有个有趣的事情，就是如果在后续事件中 onInterceptTouchEvent 返回 true，子 View 将会收到 cancel 事件。这也就是滑动冲突的解决思路。 如果没有，最终会执行自身的 onTouchEvent 进行处理 View# dispatchTouchEvent 优先判断 TouchListener ，处理 onTouch 其次 onTouchEvent 动画 帧动画 ： 顺序播放图片 补间动画 ： 只需要定义动画开始与结束两个关键帧，并指定动画变化的时间与方式等 。 只能给View加，不能给对象加，并且不会改变对象的真实属性。 属性动画 ： 补间动画增强版本。 任意 Java 对象，不再局限于 View。 分为ObjectAnimator和ValueAnimator。 ValueAnimator 类是先改变值，然后手动赋值给对象的属性从而实现动画；是间接对对象属性进行操作； ObjectAnimator 类是先改变值，然后自动赋值给对象的属性从而实现动画；是直接对对象属性进行操作； 插值器：根据时间流逝的百分比计算出当前属性值改变的百分比。 估值器：根据当前属性改变的百分比来计算改变后的属性值。 要控制动画速率的变化，就得去自定义插值器或估值器，或者使用关键帧Keyframe对象来实现。Keyframe让我们可以指定某个属性百分比时对象的属性值。 过渡动画 ：Activity 或 View 转场动画 View 绘制 onMeasure、onLayout、onDraw 测量，确定最终宽高 EXACTLY 固定宽高（设定具体值或者 match_parent） AT_MOST 自适应 UNSPECIFIED 父容器对当前 View 无限制（ 比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示 ） MeasureSpec MeasureSpec是父控件提供给子View的一个参数，作为设定自身大小参考，只是个参考，要多大，还是View自己说了算 onMeasure和onLayout为何会执行两次或多次？ 当ViewRootImpl添加View时，就会测量多次 ViewRootIpml 在进行测量、布局、绘制前会进行一次预测量，已得到最佳的窗口显示效果。 在预测量过程中进行两次协商，以得到最佳的显示尺寸，两次协商不成则直接使用窗口的尺寸进行一次预测量。 进行真正的测量，会调用一次。 Bitmap宽 * 高 * 1个像素所需字节数 修改图片加载的 BitmapFactory.Options 将存储方式设置为 Bitmap.Config.RGB_565，1像素 = 2字节 实现 Bitmap 采样压缩（inSampleSize，每隔 inSampleSize 个像素进行一次采集） Bitmap 复用（Options.inBitmap），inMutable 需设置 true BitmapRegionDecoder 图片分片显示 Bitmap 缓存 LruCache RecyclerView的特点和缓存1. RecyclerView 是如何经过测量、布局，最终绘制到屏幕上，其中大部分工作是通过委托给 LayoutManager 来实现的。不同的 LayoutManager 会有不同风格的布局显示，这是一种策略模式 2. RecyclerView 的缓存复用机制，主要是通过内部类 Recycler 来实现。 4 级缓存中依次查找 第一级缓存 mAttachedScrap&amp;mChangedScrap 两个 ArrayList，这两者主要用来缓存屏幕内的 ViewHolder（下拉刷新） 第二级缓存 mCachedViews 缓存移除屏幕之外的 ViewHolder 刚移除屏幕，可能立刻用到，但又不能缓存所有，所以默认 2，可修改，先进先出 第三级缓存 ViewCacheExtension 抽象类，开发者自己实现 第四级缓存 RecycledViewPool 缓存屏幕外的 ViewHolder mCachedViews 中淘汰出来的 ViewHolder 会先缓存到 RecycledViewPool 中 缓存到 RecycledViewPool 时，会将内部的数据清理，因此从 RecycledViewPool 中取出来的 ViewHolder 需要重新调用 onBindViewHolder 绑定数据 （同 LV 复用 convertView） 多个 RV 之间可以共享一个 RecycledViewPool 需要注意的是，RecycledViewPool 是根据 type 来获取 ViewHolder，每个 type 默认最大缓存 5 个。因此多个 RecyclerView 共享 RecycledViewPool 时，必须确保共享的 RecyclerView 使用的 Adapter 是同一个，或 view type 是不会冲突的。 动态代理的实现 –todoOOM和内存泄漏内存溢出：内存不够用 内存泄漏：本该释放的对象没有释放 内存抖动：频繁 GC，比如在 onDraw 里面频繁的创建对象 包体积如何优化删除无用代码和资源 图片压缩，某些资源考虑 CDN 网络下载 删除不常用 abi，考虑只保留 arm-v7 和 64 位 代码混淆 部分功能可考虑插件化（不同主题或字体等） ThreadLocal干嘛的？用法和原理用于线程隔离做数据存储的工具类。 ThreadLocal 是指线程的本地变量，我们可以通过 ThreadLocal 去设计只有线程内部才可以访问的变量，该变量是与其他线程所隔离的。 可以理解为一种类似于 Map 的存储结构，它的 key 是当前线程。 我们一般是在理解 Handler 跨进程机制时会接触到 ThreadLocal。 ThreadLocal 有个内部类 ThreadLocalMap，ThreadLocalMap 又有个继承于 WeakReference 的内部类 Entry 的数组，用来实际存储，Thread 这个类里面有个成员变量 threadLocals 就是 ThreadLocalMap。 我们在创建 Looper 之后会让 Looper 与当前所在线程关联，就是通过获取当前线程的 ThreadLocalMap，然后再将其放到 Entry 里面。取的时候也是根据当前线程获取其 ThreadLocalMap 再从 Entry 中取。 jvm：运行时数据分区；类加载过程；GCRoot，垃圾回收算法。–todo优化 –todoRetrofit – doing核心思想： Retrofit 通过动态代理我们定义的 service 接口代理对象，调用其方法时就会转移到InvocationHandler 对象的 invoke 方法中。 动态代理获取服务 对注解参数进行解析封装 提供转换接口（RxJava、Gson） Rxjava –doingLeakCanary实现原理LeakCanary 中对内存泄漏的检测基于 WeakReference 和 ReferenceQueue。在构建 WeakReference 对象时传入 ReferenceQueue，当 WeakReference 中传入的对象可以被回收时，会将 WeakReference 对象添加到 ReferenceQueue 中，倘若 WeakReference 中的对象无法被回收时，不会将 WeakReference 对象添加到 ReferenceQueue 中。这样便可以检测到，应该被回收的对象，却没有出现在 ReferenceQueue 中，这些对象就是造成内存泄漏的元凶。检测时机向主线程 MessageQueue 中插入了一个 IdleHandler，IdleHandler 只会在主线程空闲时才会被 Looper 从队列中取出并执行。因此能够有效避免内存检测工作占用 UI 渲染时间。 单例、观察者、装饰者，工厂，双亲委托 –todo单例：DCL、enum，静态内部类。还有饿汉式。懒汉式的使用场景：占用内存大、延迟初始化 策略模式和桥接模式的区别 –todo插件化和热更新原理 –todoApk打包流程。R文件最终会生成什么文件？aapt的作用是什么？–todo","link":"/2022/10/19/2022%20Android%20%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[]}