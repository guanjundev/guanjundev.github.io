{"pages":[{"title":"关于我","text":"关俊，Android 开发。 记录 Android，记录生活，记录自己。 好好努力，好好生活。","link":"/about/index.html"}],"posts":[{"title":"Hexo + GitHub 构建博客","text":"1. 下载安装 NodeNode官网，一步步安装即可 2. 安装 Git3. 申请 GitHub（用户名为 username ），配置 SSH Keys创建仓库，名字固定：username.github.io 4. 安装 HEXO打开Git Bash, 执行 1sudo npm install -g hexo 如果不行，执行 1npm install -g cnpm --registry=https://registry.npm.taobao.org 然后安装，执行 1npm install hexo -g 5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口执行 1hexo init 再执行 1hexo generate （hexo g 也可以） 6. 启动 HEXO执行 1hexo server 浏览器输入 http://localhost:4000 即可打开 7. 修改 blog 下 _config.yml最下方修改为 12345type: gitrepository: https://github.com/username/username.github.iobranch: master-其他配置自主修改 然后 执行 1npm install hexo-deployer-git --save 执行 1hexo deploy 现在查看 github 仓库，你会发现已经有很多文件了在浏览器打开 https://username.github.io/ 即可访问 8. 常用命令部署 123hexo cleanhexo generatehexo deploy 其他 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 case:创建一片博文 123451. hexo new \"title\"2. \\blog\\source\\_posts下会生成title.md文件，用MD编辑器打开，编写内容3. hexo generate4. hexo deploy5. 完成，重新访问blog即可看到刚才编辑的文章","link":"/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"title":"Hexo修改主题","text":"1. 挑选自己喜欢的主题进入 hexo主题网站，挑选自己喜欢的主题，点击预览图进入效果展示模版网站，点击主题名称进入主题 GitHub 仓库。 2. 下载主题执行clone命令，下载到对应的文件夹内。一般主题仓库都有相关说明。 1git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 如果该项目有其他依赖库，需要一并下载。 12npm install ejs --save-dnpm install hexo-renderer-sass --save 3. 修改配置打开博客源文件根目录下 _config.yml，修改如下： 1theme: minos 其他配置可以参考主题仓库中描述进行修改。 4. 保存和部署1hexo g -d","link":"/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"},{"title":"Handler 的使用和解析","text":"Handler 常用使用场景在 Activity 中定义一个 Handler 1234567891011121314private val mHandler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { when(msg.what) { CODE_GET_USER_INFO -&gt; { val user = msg.obj as User textViewName.text = user.name textViewSite.text = user.site imageViewIcon.load(user.icon){ transformations(CircleCropTransformation()) } } } }} 在子线程获取到数据之后通过 Handler 将数据传到 UI 线程进行处理 12345678910111213Thread { val request = Request.Builder() .url(\"http://10.0.2.2:8000/user\") .build() val response = OkHttpClient().newCall(request).execute() val result = response.body?.string() val user = Gson().fromJson(result, User::class.java) Message.obtain().also { it.what = CODE_GET_USER_INFO it.obj = user mHandler.sendMessage(it) }}.start() 打开 Handler 源文件，可以看到这样的注释 There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future; and (2) to enqueue an action to be performed on a different thread than your own. 简单概述一下，Handler 两个用途：（1）在未来某个时间点执行事件 （2）跨线程执行事件 源码分析Handler 构造函数123456789101112131415161718public Handler(@NonNull Looper looper) { this(looper, null, false);}final Looper mLooper;final MessageQueue mQueue;final Callback mCallback;final boolean mAsynchronous;public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;}public interface Callback { boolean handleMessage(@NonNull Message msg);} 在 Handler 的构造函数中初始化了两个重要的成员变量：mLooper 和 mQueue 我们传人的参数是 Looper.getMainLooper()，代码如下 123456private static Looper sMainLooper;public static Looper getMainLooper() { synchronized (Looper.class) { return sMainLooper; }} Looper 中的 sMainLooper 又是在哪里初始化的呢？我们看 ActivityThread 这个类中的 main 函数 1234567public static void main(String[] args) { ... Looper.prepareMainLooper(); ... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");} prepareMainLooper() Looper 的 prepareMainLooper 函数以及后续相关函数调用 12345678910111213public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(\"The main Looper has already been prepared.\"); } sMainLooper = myLooper(); }}public static @Nullable Looper myLooper() { return sThreadLocal.get();} 实际上调用了 prepare 函数。 12345678static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed));} 1234567final MessageQueue mQueue;final Thread mThread; private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} 至此，我们可以确定，在 ActivityThread 执行的时候，初始化了 Looper，并且初始化了 Looper 中两个成员变量：消息队列 和 当前线程对象。 值得注意的是： 一个线程只能创建一个 Looper，也就是说线程和 Looper 是一一对应的，且它俩是有一定的绑定关系的 Looper 中有一个 ThreadLocal 数据结构，用来存储线程和 Looper，维系两者的绑定关系 我们看一下 ThreadLocal 的相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue();}public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);}void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);}ThreadLocalMap getMap(Thread t) { return t.threadLocals;}static class ThreadLocalMap { static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } ... private Entry[] table; ...} 可以看出，ThreadLocal 中有个 ThreadLocalMap 类，它其实跟 Map 没啥关系。ThreadLocalMap 有个继承于 WeakReference 的内部类 Entry 用来存储 Looper，而 ThreadLocalMap 是赋值给 Thread 的成员变量 threadLocals 的。 那么也就是通过这种方式实现了一个线程和一个 Looper 的绑定。 Looper.loop()初始化的动作做完之后，执行了 Looper.loop() 123456789101112131415161718public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } if (me.mInLoop) { Slog.w(TAG, \"Loop again would have the queued messages be executed\" + \" before this one completed.\"); } me.mInLoop = true; ... for (;;) { if (!loopOnce(me, ident, thresholdOverride)) { return; } }} 12345678910private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) { Message msg = me.mQueue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return false; } ... msg.target.dispatchMessage(msg); ...} 我们可以看到 loop 函数中执行了一个死循环，不断的执行 loopOnce 函数。 在 loopOnce 函数中我们需要注意 2 点： Message msg = me.mQueue.next(); msg.target.dispatchMessage(msg); mQueue.next()注意看 next 后面的的注释 might block，这个函数是会阻塞的。 123456789101112131415161718192021222324252627282930313233343536Message next() { ... for (;;) { ... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { ... } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; msg.markInUse(); return msg; } } ... } ... }} 这里可以看到，next 其实也是执行了一个死循环，不断的取出下一个 Message ，判断其出发时间是否符合，然后将其返回。倘若没有 Message ，nativePollOnce 会阻塞该函数，直到新的 Message 进入 MessageQueue。 msg.target.dispatchMessage(msg)取到符合触发时间的消息后，会执行该函数。查看 Message 类我们会发现，它有一个成员变量 1Handler target; 然后执行了 Handler 的 dispatchMessage 函数，传入了当前触发的 Message。 有 2 点需要理解： Message 中的 target 是什么时候初始化的 Handler 中的 dispatchMessage 做了什么 回头看最开始简单的使用案例，我们执行了 mHandler.sendMessage(it) 将消息进行发送，进入该函数。 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(@NonNull Message msg) { return sendMessageDelayed(msg, 0);}public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);}public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);}private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);} 最终调用了 enqueueMessage 将当前 Handler 对象赋值给此次 Message 的 target，并将消息添加到消息队列。 需要注意的是 MessageQueue 中的 enqueueMessage 函数中，除了将 Message 添加到消息队列，还在某些条件下执行了一个函数 nativeWake()，这个函数就是对应上文中 nativePollOnce() 的，将阻塞唤醒。 最后我们再看 dispatchMessage 12345678910111213141516public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }}private static void handleCallback(Message message) { message.callback.run();} 其实是将消息进行分发消费。这里主要有 3 种消费方式 Message 中的 callback（其实是一个 Runnable ） 通过 run 进行处理 Handler 中的 Callback 通过 handleMessage 进行处理 直接通过 Handler 中的 handleMessage 进行处理 这也对应 Handler 的三种使用方式。 Handler 的三种使用方式 handler.post(Runnable r) 123456789public final boolean post(@NonNull Runnable r) { return sendMessageDelayed(getPostMessage(r), 0);}private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m;} Handler(Looper looper, Callback callback) 123public Handler(@NonNull Looper looper, @Nullable Callback callback) { this(looper, callback, false);} 文中常用使用场景 1234private val mHandler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { }} 总结重新回到初始对于 Handler 用途的描述： Handler 两个用途：（1）在未来某个时间点执行事件 （2）跨线程执行事件 1、使用 sendMessageDelayed 等 API 实现将消息添加到消息队列，MessageQueue 的 next 循环取出消息的时候会判断触发时间，符合即触发消息分发处理。 2、一个 Thread 中可以有一个 Looper，并且两种有映射关系，而 Handler 持有其所在线程的 Looper 和 MessageQueue。在线程 A 中创建了基于此线程的 Handler，Handler 中的 Looper 与线程 A 关联，线程 A 中执行死循环不断的从 MessageQueue 中取出消息进行处理。线程 B 中使用该 Handler 将 Message 发送到 MessageQueue 中，进入线程 A 的 loop 执行逻辑，从而实现跨线程。","link":"/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"}],"categories":[]}