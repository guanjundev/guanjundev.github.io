<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Handler 的使用和解析</title>
      <link href="/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h2 id="Handler-常用使用场景"><a href="#Handler-常用使用场景" class="headerlink" title="Handler 常用使用场景"></a>Handler 常用使用场景</h2><p>在 Activity 中定义一个 Handler</p><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mHandler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) {</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> {</span><br><span class="line">        <span class="hljs-keyword">when</span>(msg.what) {</span><br><span class="line">            CODE_GET_USER_INFO -&gt; {</span><br><span class="line">                <span class="hljs-keyword">val</span> user = msg.obj <span class="hljs-keyword">as</span> User</span><br><span class="line">                textViewName.text = user.name</span><br><span class="line">                textViewSite.text = user.site</span><br><span class="line">                imageViewIcon.load(user.icon){</span><br><span class="line">                    transformations(CircleCropTransformation())</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在子线程获取到数据之后通过 Handler 将数据传到 UI 线程进行处理</p><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread {</span><br><span class="line">    <span class="hljs-keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(<span class="hljs-string">"http://10.0.2.2:8000/user"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="hljs-keyword">val</span> response = OkHttpClient().newCall(request).execute()</span><br><span class="line">    <span class="hljs-keyword">val</span> result = response.body?.string()</span><br><span class="line">    <span class="hljs-keyword">val</span> user = Gson().fromJson(result, User::<span class="hljs-keyword">class</span>.java)</span><br><span class="line">    Message.obtain().also {</span><br><span class="line">        it.what = CODE_GET_USER_INFO</span><br><span class="line">        it.obj = user</span><br><span class="line">        mHandler.sendMessage(it)</span><br><span class="line">    }</span><br><span class="line">}.start()</span><br></pre></td></tr></tbody></table></figure><p>打开 Handler 源文件，可以看到这样的注释</p><blockquote><p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.</p></blockquote><p>简单概述一下，Handler 两个用途：（1）在未来某个时间点执行事件 （2）跨线程执行事件</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Handler-构造函数"><a href="#Handler-构造函数" class="headerlink" title="Handler 构造函数"></a>Handler 构造函数</h3><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="hljs-keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="hljs-keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> {</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="title class_">Callback</span> {</span><br><span class="line">    <span class="hljs-type">boolean</span> <span class="title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Handler 的构造函数中初始化了两个重要的成员变量：mLooper 和 mQueue</p><p>我们传人的参数是 Looper.getMainLooper()，代码如下</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Looper sMainLooper;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="title function_">getMainLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (Looper.class) {</span><br><span class="line">        <span class="hljs-keyword">return</span> sMainLooper;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Looper 中的 sMainLooper 又是在哪里初始化的呢？我们看 ActivityThread 这个类中的 main 函数</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">main</span><span class="hljs-params">(String[] args)</span> {</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="prepareMainLooper"><a href="#prepareMainLooper" class="headerlink" title="prepareMainLooper()"></a>prepareMainLooper()</h3><p> Looper 的 prepareMainLooper 函数以及后续相关函数调用</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    prepare(<span class="hljs-literal">false</span>);</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (Looper.class) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="hljs-string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        }</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="title function_">myLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sThreadLocal.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上调用了 prepare 函数。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    }</span><br><span class="line">    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="hljs-keyword">final</span> Thread mThread;</span><br><span class="line">    </span><br><span class="line"><span class="hljs-keyword">private</span> <span class="title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> {</span><br><span class="line">    mQueue = <span class="hljs-keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，我们可以确定，在 ActivityThread 执行的时候，初始化了 Looper，并且初始化了 Looper 中两个成员变量：消息队列 和 当前线程对象。</p><p>值得注意的是：</p><ol><li>一个线程只能创建一个 Looper，也就是说线程和 Looper 是一一对应的，且它俩是有一定的绑定关系的</li><li>Looper 中有一个 ThreadLocal<looper> 数据结构，用来存储线程和 Looper，维系两者的绑定关系</looper></li></ol><p>我们看一下 ThreadLocal 的相关代码</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> T <span class="title function_">get</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) {</span><br><span class="line">      ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;</span><br><span class="line">            <span class="hljs-keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">set</span><span class="hljs-params">(T value)</span> {</span><br><span class="line">    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)</span><br><span class="line">        map.set(<span class="hljs-built_in">this</span>, value);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> <span class="title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> {</span><br><span class="line">    t.threadLocals = <span class="hljs-keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="hljs-params">(Thread t)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="title class_">ThreadLocalMap</span> {</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">          <span class="hljs-built_in">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">private</span> Entry[] table;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，ThreadLocal 中有个 ThreadLocalMap 类，它其实跟 Map 没啥关系。ThreadLocalMap 有个继承于 WeakReference 的内部类 Entry 用来存储 Looper，而 ThreadLocalMap 是赋值给 Thread 的成员变量 threadLocals 的。</p><p>那么也就是通过这种方式实现了一个线程和一个 Looper 的绑定。</p><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><p>初始化的动作做完之后，执行了 Looper.loop()</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">loop</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();</span><br><span class="line">    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (me.mInLoop) {</span><br><span class="line">        Slog.w(TAG, <span class="hljs-string">"Loop again would have the queued messages be executed"</span></span><br><span class="line">                + <span class="hljs-string">" before this one completed."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="hljs-literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) {</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> {</span><br><span class="line">    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    msg.target.dispatchMessage(msg); </span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到 loop 函数中执行了一个死循环，不断的执行 loopOnce 函数。</p><p>在 loopOnce 函数中我们需要注意 2 点：</p><ol><li>Message msg = me.mQueue.next();</li><li>msg.target.dispatchMessage(msg);</li></ol><h4 id="mQueue-next"><a href="#mQueue-next" class="headerlink" title="mQueue.next()"></a>mQueue.next()</h4><p>注意看 next 后面的的注释 <code>might block</code>，这个函数是会阻塞的。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="hljs-params">()</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) {</span><br><span class="line">        ...</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {</span><br><span class="line">            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;</span><br><span class="line">            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) {</span><br><span class="line">                <span class="hljs-keyword">do</span> {</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                } <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (now &lt; msg.when) {</span><br><span class="line">                    ...</span><br><span class="line">                } <span class="hljs-keyword">else</span> {</span><br><span class="line">                    <span class="hljs-comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="hljs-literal">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) {</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    } <span class="hljs-keyword">else</span> {</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    }</span><br><span class="line">                    msg.next = <span class="hljs-literal">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="hljs-keyword">return</span> msg;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到，next 其实也是执行了一个死循环，不断的取出下一个 Message ，判断其出发时间是否符合，然后将其返回。倘若没有 Message  ，nativePollOnce 会阻塞该函数，直到新的 Message 进入 MessageQueue。</p><h4 id="msg-target-dispatchMessage-msg"><a href="#msg-target-dispatchMessage-msg" class="headerlink" title="msg.target.dispatchMessage(msg)"></a>msg.target.dispatchMessage(msg)</h4><p>取到符合触发时间的消息后，会执行该函数。查看 Message 类我们会发现，它有一个成员变量</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler target;</span><br></pre></td></tr></tbody></table></figure><p>然后执行了 Handler 的 dispatchMessage 函数，传入了当前触发的 Message。</p><p>有 2 点需要理解：</p><ol><li>Message 中的 target 是什么时候初始化的</li><li>Handler 中的 dispatchMessage 做了什么</li></ol><p>回头看最开始简单的使用案例，我们执行了 mHandler.sendMessage(it) 将消息进行发送，进入该函数。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) {</span><br><span class="line">      delayMillis = <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> {</span><br><span class="line">    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;</span><br><span class="line">    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">          <span class="hljs-built_in">this</span> + <span class="hljs-string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="hljs-string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> {</span><br><span class="line">    msg.target = <span class="hljs-built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAsynchronous) {</span><br><span class="line">        msg.setAsynchronous(<span class="hljs-literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终调用了 enqueueMessage 将当前 Handler 对象赋值给此次 Message 的 target，并将消息添加到消息队列。</p><p>需要注意的是 MessageQueue 中的 enqueueMessage 函数中，除了将 Message 添加到消息队列，还在某些条件下执行了一个函数 <code>nativeWake()</code>，这个函数就是对应上文中 <code>nativePollOnce()</code> 的，将阻塞唤醒。</p><p>最后我们再看 dispatchMessage</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="hljs-keyword">else</span> {</span><br><span class="line">        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">handleCallback</span><span class="hljs-params">(Message message)</span> {</span><br><span class="line">    message.callback.run();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实是将消息进行分发消费。这里主要有 3 种消费方式</p><ol><li>Message 中的 callback（其实是一个 Runnable ） 通过 run 进行处理</li><li>Handler 中的 Callback 通过 handleMessage 进行处理</li><li>直接通过 Handler 中的 handleMessage 进行处理</li></ol><p>这也对应 Handler 的三种使用方式。</p><h2 id="Handler-的三种使用方式"><a href="#Handler-的三种使用方式" class="headerlink" title="Handler 的三种使用方式"></a>Handler 的三种使用方式</h2><ul><li>handler.post(Runnable r)</li></ul><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable r)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="hljs-params">(Runnable r)</span> {</span><br><span class="line">    <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="hljs-keyword">return</span> m;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Handler(Looper looper, Callback callback)</li></ul><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>(looper, callback, <span class="hljs-literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>文中常用使用场景</li></ul><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mHandler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) {</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Handler 大致可以分为 3 个阶段去理解</p><ol><li>初始化阶段<br> 在创建 Handler 对象的同时，会初始化 Looper  和 Looper 中的 MessageQueue。 Looper 的初始化包括对象创建和 loop() 调用。</li></ol><ul><li>Looper 的初始化涉及到 Handler 所工作的线程，井且会将 Looper 对象存储在 Threadlocal 中，再赋值给该线程的成员变量。这样线程和 Looper 就建立了绑定关系，且一个线程最多只能创建一个Looper，初始化多次会拋出异常。值得注意的是在 UI 线程是不需要调用 Looper.prepare() 去初始化的，因为在ActivityThread 的 main 函数，也就是APP进程启动入口里面，已经执行了 Looper.prepareMainLooper() 和 Looper.loop()。</li><li>loop() 调用其实就是执行了一个死循环，然后从 MessageQueue 中取出 Message， 取到了就发给 Handler 去处理，取不到就阻塞。</li></ul><ol start="2"><li>消息发送<br> 通过 Handler 将 Message 加入 MessageQueue。</li></ol><ul><li>这里首先会将 Handler 与 Message 进行绑定，以便后续 Message 取出后交给Handler 进行处理</li><li>按照 Message 的执行时间将其插入到 MessageQueue 中</li></ul><ol start="3"><li>消息分发<br> 在loop()循环中检查到符合执行时间的 Message 后，这里对应 Handler 的不同构造方法和消息发送方式有 3种分发情况。</li></ol><ul><li><p>handler.post(Runnable n)，优先判断 Message 中是否有 Runnable对象，有的话执行其 run 方法</p></li><li><p>Handler(Looper looper, Callback callback)，其次再判断是否在创建 Handler 的时候传入了 Callback，如果有，执行其 handleMessage 方法</p></li><li><p>上述两种都不满足的话，执行 Handler 自身的 handleMessage 方法</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo修改主题</title>
      <link href="/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
      <url>/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h3 id="1-挑选自己喜欢的主题"><a href="#1-挑选自己喜欢的主题" class="headerlink" title="1. 挑选自己喜欢的主题"></a>1. 挑选自己喜欢的主题</h3><p>进入 <a href="https://hexo.io/themes/">hexo主题网站</a>，挑选自己喜欢的主题，点击预览图进入效果展示模版网站，点击主题名称进入主题 GitHub 仓库。</p><h3 id="2-下载主题"><a href="#2-下载主题" class="headerlink" title="2. 下载主题"></a>2. 下载主题</h3><p>执行clone命令，下载到对应的文件夹内。一般主题仓库都有相关说明。</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos</span><br></pre></td></tr></tbody></table></figure><p>如果该项目有其他依赖库，需要一并下载。</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs --save-d</span><br><span class="line">npm install hexo-renderer-sass --save</span><br></pre></td></tr></tbody></table></figure><h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h3><p>打开博客源文件根目录下  <code>_config.yml</code>，修改如下：</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: minos</span><br></pre></td></tr></tbody></table></figure><p>其他配置可以参考主题仓库中描述进行修改。</p><h3 id="4-保存和部署"><a href="#4-保存和部署" class="headerlink" title="4. 保存和部署"></a>4. 保存和部署</h3><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 构建博客</title>
      <link href="/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h4 id="1-下载安装-Node"><a href="#1-下载安装-Node" class="headerlink" title="1. 下载安装 Node"></a>1. 下载安装 Node</h4><p><a href="https://nodejs.org/en/">Node官网</a>，一步步安装即可</p><h4 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h4><h4 id="3-申请-GitHub（用户名为-username-），配置-SSH-Keys"><a href="#3-申请-GitHub（用户名为-username-），配置-SSH-Keys" class="headerlink" title="3. 申请 GitHub（用户名为 username ），配置 SSH Keys"></a>3. 申请 GitHub（用户名为 username ），配置 SSH Keys</h4><p>创建仓库，名字固定：<code>username.github.io</code></p><h4 id="4-安装-HEXO"><a href="#4-安装-HEXO" class="headerlink" title="4. 安装 HEXO"></a>4. 安装 HEXO</h4><p>打开<code>Git Bash</code>, 执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></tbody></table></figure><p>如果不行，执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><p>然后安装，执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></tbody></table></figure><h4 id="5-创建一个文件夹-blog-，在文件夹内-Shift-右键打开命令窗口"><a href="#5-创建一个文件夹-blog-，在文件夹内-Shift-右键打开命令窗口" class="headerlink" title="5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口"></a>5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口</h4><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></tbody></table></figure><p>再执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></tbody></table></figure><p><em>（hexo g 也可以）</em></p><h4 id="6-启动-HEXO"><a href="#6-启动-HEXO" class="headerlink" title="6. 启动 HEXO"></a>6. 启动 HEXO</h4><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure><p>浏览器输入 <code>http://localhost:4000</code> 即可打开</p><h4 id="7-修改-blog-下-config-yml"><a href="#7-修改-blog-下-config-yml" class="headerlink" title="7. 修改 blog 下 _config.yml"></a>7. 修改 blog 下 _config.yml</h4><p>最下方修改为</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repository: https://github.com/username/username.github.io</span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line">-其他配置自主修改</span><br></pre></td></tr></tbody></table></figure><p>然后</p><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>现在查看 github 仓库，你会发现已经有很多文件了<br>在浏览器打开 <code>https://username.github.io/</code> 即可访问</p><h4 id="8-常用命令"><a href="#8-常用命令" class="headerlink" title="8. 常用命令"></a>8. 常用命令</h4><p>部署</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>其他</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help  #查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></tbody></table></figure><p>case:创建一片博文</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. hexo new "title"</span><br><span class="line">2. \blog\source\_posts下会生成title.md文件，用MD编辑器打开，编写内容</span><br><span class="line">3. hexo generate</span><br><span class="line">4. hexo deploy</span><br><span class="line">5. 完成，重新访问blog即可看到刚才编辑的文章</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
