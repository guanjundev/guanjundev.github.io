<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022 Android 面试准备</title>
      <link href="/2022/10/19/2022%20Android%20%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2022/10/19/2022%20Android%20%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>singleTask：单例，taskAffinity：指定 Activity 要压入的 task</p><p>singleInstance：单例且独立 task</p><p>allowTaskReparenting 赋予 Activity 在各个 Task 中间转移的特性</p><ul><li><p>Activity 的 onSaveInstance 方法何时调用？它跟onPause、onStop的调用顺序如何？</p></li><li><p>Binder 传输限制通常 1 M，不同厂商不同版本会有区别。</p><ul><li>非必须的字段添加 transient 禁止序列化</li><li>转 json 传输</li></ul></li></ul><h2 id="startActivity的具体过程"><a href="#startActivity的具体过程" class="headerlink" title="startActivity的具体过程"></a>startActivity的具体过程</h2><ul><li><p>执行到 Instrumentation#execStartActivity</p></li><li><p>通过 ActivityTaskManager.getService() 获取 ATMS（Binder）代理，执行其  startActivity</p><ul><li>在系统启动的时候， 有从 init 到 zygote 到 system_server 的一套流程</li></ul></li><li><p>构建一个  ActivityStarter ，根据请求参数进行启动</p><ul><li>权限检查，处理异常</li><li>封装 ActivityRecord，处理更新 task 栈帧信息</li></ul></li><li><p>判断目标进程是否已存在</p><ul><li>已存在：那么目标 ActivityThread 已经启动且 ATMS 是持有其内部 Binder（ApplicationThread）代理的。开启事务，通过 ActivityThread 的 Binder 代理，发送事务执行消息，最终执行 handleLaunchActivity<ul><li>反射创建 Activity 对象</li><li>调用 Activity#attach<ul><li>构建 PhoneWindow，将 Activity 与其关联，并持有 WindowManagerImpl 的引用</li></ul></li><li>调用 Instrumentation#callActivityOnCreate 执行 Activity 的 onCreate 生命周期</li></ul></li><li>不存在：ATMS 通过 startProcessAsync 发送异步消息通知 AMS 启动进程<ul><li>这里是通过 PooledLambda 构建了一个 Message，再通过 mH.sendMessage 发送消息，但是我在 mH 中没有看到相关处理逻辑，进入到 PooledLambda  中发现，其实是通过 Message.obtain().setCallback 生成的 Message，所以这里其实是使用的 Message 中的 Runnable x消息分发触发 run 方法从而执行的传入的 ActivityManagerInternal::startProcess 方法，最终由实现了该接口的 AMS 的内部类 LocalService 执行</li><li>AMS.LocalService#startProcess -&gt; ProcessList#startProcess -&gt; Zygote 创建进程，执行applicationInit，调用 ActivityThread.main。这里 AMS 将持有 ActivityThread 的 Binder 代理<ul><li>prepareMainLooper</li><li>构建 ActivityThread，执行 attach 方法，<ul><li>通过 getService 调用 AMS#attachApplication，将 ApplicationThread（Binder）传入</li><li>AMS 通过 ApplicationThread 调用 bindApplication 又回到 ActivityThread</li><li>ActivityThread 中执行 sendMessage(H.BIND_APPLICATION, data)，实际执行 handleBindApplication</li><li>构建 Instrumentation 和 Application，Instrumentation#callApplicationOnCreate</li></ul></li><li>Looper.loop()</li></ul></li></ul></li></ul></li><li><p>AMS 继续执行 Activity 的启动处理</p></li></ul><blockquote><p>Flag，launchMode，taskAffinity</p></blockquote><h2 id="Activity-setContentView的具体过程"><a href="#Activity-setContentView的具体过程" class="headerlink" title="Activity#setContentView的具体过程"></a>Activity#setContentView的具体过程</h2><p>①PhoneWindow是何时创建的，它的作用是什么？<br>    创建 Activity 时调用其 attach 方法中创建的，…</p><p>②setContentView中传递的资源文件是如何变成View对象的？<br>    LayoutInflater.from(mContext).inflate(resId, contentParent);</p><p>③布局文件对应的View对象是添加到哪里的？<br>    DecorView 中的 contentParent 中</p><p>④Activity的布局是何时显示出来的？<br>    只有执行完 onResume 之后 Activity 中的内容才是屏幕可见状态。onCreate 阶段只是初始化了 Activity 需要显示的内容，而在 onResume 阶段才会将 PhoneWindow 中的 DecorView 真正的绘制到屏幕上。</p><p>⑤ViewRootImpl是何时初始化的？它的作用是什么？</p><p>⑥Choreography了解么？作用是什么？</p><p><strong>初始化阶段</strong></p><ul><li>AppCompatDelegateImpl#setContentView</li><li>执行 PhoneWindow#getDecorView()，构建 DecorView（FrameLayout），从DecorView 中获取 mContentParent</li><li>将 resId 通过 inflate 转化成 View 添加到 mContentParent 中</li></ul><p><strong>绘制阶段</strong></p><ul><li><p>执行 ActivityThread#handleResumeActivity，调用 WindowManager.addView</p></li><li><p>实际调用 WindowManagerGlobal#addView</p></li><li><p>构建 ViewRootImpl，调用其 setView 方法（将 DecorView 添加到 WMS）</p><ul><li>requestLayout() - 执行完整的 View 树的渲染操作。调用此方法后 ViewRootImpl 所关联的 View 也执行 measure - layout - draw 操作，确保在 View 被添加到 Window 上显示到屏幕之前，已经完成测量和绘制操作。<ul><li>checkThread() 检查线程是否合法，需与 ViewRootImpl 一致，即 UI 线程</li><li>scheduleTraversals() - 方法中添加了同步屏障，实际执行 performTraversals()，这个方法就是真正的开始 View 绘制流程：measure –&gt; layout –&gt; draw 。<ul><li>performLayout() <ul><li>measureHierarchy() - performMeasure() - mView.measure()</li><li>host.layout() – host = mView</li></ul></li><li>performDraw()<ul><li>draw(fullRedrawNeeded)<ul><li>mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this) – 硬件加速绘制（GPU）</li><li>drawSoftware() – 软件绘制（CPU）<ul><li>mView.draw(canvas) </li><li>surface.unlockCanvasAndPost(canvas) – 将 Canvas 中的内容提交给 SurfaceFlinger 进行合成处理。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>调用 mWindowSession.addToDisplayAsUser，mWS = WindowManagerGlobal.getWindowSession()<ul><li>getWindowSession - 通过 ipc 调用 WMS#openSession 获取 Session，调用其 addToDisplayAsUser，将 ViewRootImpl 弱引用存储，整个给到 WMS </li><li>实际调用 WMS#addWindow，完成后面的添加动作</li></ul></li><li>设置输入管道，用来接收屏幕触摸事件</li></ul></li></ul><blockquote><p>ViewRootImpl 中有一个非常重要的对象 Surface，之所以说 ViewRootImpl 的一个核心功能就是负责 UI 渲染，原因就在于在 ViewRootImpl 中会将我们在 draw 方法中绘制的 UI 元素，绑定到这个 Surface 上。如果说 Canvas 是画板，那么 Surface 就是画板上的画纸，Surface 中的内容最终会被传递给底层的 SurfaceFlinger，最终将 Surface 中的内容进行合成并显示的屏幕上。</p></blockquote><p><strong>硬件加速绘制</strong></p><p>并不是所有的 2D 绘制操作都支持硬件加速</p><p>View 视图被抽象成 RenderNode 节点，View 中的绘制操作都会被抽象成一个个 DrawOp，每个 DrawOp 有对应的 OpenGL 绘制命令。</p><p>遍历 View 递归构建 DrawOp，根据 Canvas 将所有的 DrawOp 进行缓存操作。所有的 DrawOp 对应的 OpenGL 命令构建完成之后，就需要使用 RenderProxy 向 RenderThread 发送消息，请求 OpenGL 线程进行渲染。整个渲染过程是通过 GPU 并在不同线程绘制渲染图形，因此整个流程会更加顺畅。</p><p><strong>Invalidate</strong></p><p>这个方法跟 requestLayout 的区别在于，它不一定会触发 View 的 measure 和 layout 的操作，多数情况下只会执行 draw 操作。</p><p>measure 方法中有个强制布局的标志位，只有当这个标志位为 true 才会执行 onMeasure，requestLayout 中会设置，但是 invalidate 不会。</p><p>当调用 invalidate 方法时，如果 View 的位置并没有发生改变，则 View 不会触发重新布局的操作。</p><p><strong>postInvalidate</strong></p><p>invalidate 是在 UI 线程调用，postInvalidate 是在非 UI 线程调用。</p><h2 id="事件分发，滑动冲突"><a href="#事件分发，滑动冲突" class="headerlink" title="事件分发，滑动冲突"></a>事件分发，滑动冲突</h2><p>触摸事件通过驱动层 WMS 到达 DecorView 的 dispatchTouchEvent，执行 mWindow.cb.dispatchTouchEvent，这里的 cb 就是 Activity（在 Activity 的 attach 中设置），再从 Activity 的 dispatchTouchEvent 到 PhoneWindow.superDispatchTouchEvent，再到 DecorView.superDispatchTouchEvent</p><p>从 ViewGroup#dispatchTouchEvent 开始</p><ul><li>判断 ViewGroup 是否拦截（down 事件 或者 TouchTarget 不为空），通过 onInterceptTouchEvent 判断</li><li>不拦截，事件分发给子 View 继续处理<ul><li>前提是 down 事件</li><li>遍历子 View，View 坐标范围符合且不在动画状态</li><li>dispatchTransformedTouchEvent 将事件分发给 View# dispatchTouchEvent ，如果 View 消费事件，赋值给 TouchTarget</li></ul></li><li>如果有子 View 消费事件，将后续事件直接交其处理<ul><li>这里有个有趣的事情，就是如果在后续事件中 onInterceptTouchEvent 返回 true，子 View 将会收到 cancel 事件。这也就是滑动冲突的解决思路。</li></ul></li><li>如果没有，最终会执行自身的 onTouchEvent 进行处理</li></ul><p>View# dispatchTouchEvent </p><ul><li>优先判断 TouchListener ，处理 onTouch</li><li>其次 onTouchEvent</li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul><li><p>帧动画 ： 顺序播放图片 </p></li><li><p>补间动画 ： 只需要定义动画开始与结束两个关键帧，并指定动画变化的时间与方式等 。 只能给View加，不能给对象加，并且不会改变对象的真实属性。 </p></li><li><p>属性动画 ：  补间动画增强版本。 任意 Java 对象，不再局限于 View。 分为ObjectAnimator和ValueAnimator。 </p></li><li><p>ValueAnimator 类是先改变值，然后手动赋值给对象的属性从而实现动画；是间接对对象属性进行操作；</p></li><li><p>ObjectAnimator 类是先改变值，然后自动赋值给对象的属性从而实现动画；是直接对对象属性进行操作；</p></li></ul><p>  <strong>插值器</strong>：根据时间流逝的百分比计算出当前属性值改变的百分比。</p><p>  <strong>估值器</strong>：根据当前属性改变的百分比来计算改变后的属性值。</p><p>   要控制动画速率的变化，就得去自定义插值器或估值器，或者使用关键帧<code>Keyframe</code>对象来实现。<code>Keyframe</code>让我们可以指定<strong>某个属性百分比</strong>时对象的<strong>属性值</strong>。 </p><ul><li>过渡动画 ：Activity 或 View 转场动画</li></ul><h2 id="View-绘制"><a href="#View-绘制" class="headerlink" title="View 绘制"></a>View 绘制</h2><ul><li><p>onMeasure、onLayout、onDraw</p><ul><li><p>测量，确定最终宽高</p><ul><li>EXACTLY 固定宽高（设定具体值或者 match_parent）</li><li>AT_MOST 自适应</li><li>UNSPECIFIED 父容器对当前 View 无限制（ 比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示 ）</li></ul></li><li><p>MeasureSpec</p><p> MeasureSpec是父控件提供给子View的一个参数，作为设定自身大小参考，只是个参考，要多大，还是View自己说了算</p></li></ul></li><li><p>onMeasure和onLayout为何会执行两次或多次？</p><ul><li><p>当<code>ViewRootImpl</code>添加<code>View</code>时，就会测量多次 </p></li><li><p>ViewRootIpml 在进行测量、布局、绘制前会进行一次预测量，已得到最佳的窗口显示效果。</p><p>在预测量过程中进行两次协商，以得到最佳的显示尺寸，两次协商不成则直接使用窗口的尺寸进行一次预测量。</p></li><li><p>进行真正的测量，会调用一次。</p></li></ul></li></ul><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>宽 * 高 * 1个像素所需字节数</p><ul><li><p>修改图片加载的 BitmapFactory.Options</p><ul><li>将存储方式设置为 Bitmap.Config.RGB_565，1像素 = 2字节</li><li>实现 Bitmap 采样压缩（inSampleSize，每隔 inSampleSize 个像素进行一次采集）</li></ul></li><li><p>Bitmap 复用（Options.inBitmap），inMutable 需设置 true</p></li><li><p>BitmapRegionDecoder 图片分片显示</p></li><li><p>Bitmap 缓存</p><ul><li>LruCache</li></ul></li></ul><h2 id="RecyclerView的特点和缓存"><a href="#RecyclerView的特点和缓存" class="headerlink" title="RecyclerView的特点和缓存"></a>RecyclerView的特点和缓存</h2><p><strong>1. RecyclerView 是如何经过测量、布局，最终绘制到屏幕上，其中大部分工作是通过委托给 LayoutManager 来实现的。不同的 LayoutManager 会有不同风格的布局显示，这是一种策略模式</strong></p><p><strong>2. RecyclerView 的缓存复用机制，主要是通过内部类 Recycler 来实现。</strong></p><blockquote><p>4 级缓存中依次查找</p></blockquote><ul><li><p>第一级缓存 mAttachedScrap&amp;mChangedScrap</p><ul><li>两个 ArrayList，这两者主要用来缓存屏幕内的 ViewHolder（下拉刷新）</li></ul></li><li><p>第二级缓存 mCachedViews</p><ul><li>缓存移除屏幕之外的 ViewHolder</li><li>刚移除屏幕，可能立刻用到，但又不能缓存所有，所以默认 2，可修改，先进先出</li></ul></li><li><p>第三级缓存 ViewCacheExtension</p><ul><li>抽象类，开发者自己实现</li></ul></li><li><p>第四级缓存 RecycledViewPool</p><ul><li><p>缓存屏幕外的 ViewHolder</p></li><li><p>mCachedViews 中淘汰出来的 ViewHolder 会先缓存到 RecycledViewPool 中</p></li><li><p>缓存到 RecycledViewPool 时，会将内部的数据清理，因此从 RecycledViewPool 中取出来的 ViewHolder 需要重新调用 onBindViewHolder 绑定数据 （同 LV 复用 convertView）</p></li><li><p>多个 RV 之间可以共享一个 RecycledViewPool</p><p><strong>需要注意的是，RecycledViewPool 是根据 type 来获取 ViewHolder，每个 type 默认最大缓存 5 个。</strong>因此多个 RecyclerView 共享 RecycledViewPool 时，必须确保共享的 RecyclerView 使用的 Adapter 是同一个，或 view type 是不会冲突的。</p></li></ul></li></ul><h2 id="动态代理的实现-–todo"><a href="#动态代理的实现-–todo" class="headerlink" title="动态代理的实现 –todo"></a>动态代理的实现 –todo</h2><h2 id="OOM和内存泄漏"><a href="#OOM和内存泄漏" class="headerlink" title="OOM和内存泄漏"></a>OOM和内存泄漏</h2><p>内存溢出：内存不够用</p><p>内存泄漏：本该释放的对象没有释放</p><p>内存抖动：频繁 GC，比如在 onDraw 里面频繁的创建对象</p><h2 id="包体积如何优化"><a href="#包体积如何优化" class="headerlink" title="包体积如何优化"></a>包体积如何优化</h2><p>删除无用代码和资源</p><p>图片压缩，某些资源考虑 CDN 网络下载</p><p>删除不常用 abi，考虑只保留 arm-v7 和 64 位</p><p>代码混淆</p><p>部分功能可考虑插件化（不同主题或字体等）</p><h2 id="ThreadLocal干嘛的？用法和原理"><a href="#ThreadLocal干嘛的？用法和原理" class="headerlink" title="ThreadLocal干嘛的？用法和原理"></a>ThreadLocal干嘛的？用法和原理</h2><p>用于线程隔离做数据存储的工具类。</p><p>ThreadLocal 是指线程的本地变量，我们可以通过 ThreadLocal 去设计只有线程内部才可以访问的变量，该变量是与其他线程所隔离的。 可以理解为一种类似于 Map 的存储结构，它的 key 是当前线程。</p><p>我们一般是在理解 Handler 跨进程机制时会接触到 ThreadLocal。</p><p>ThreadLocal 有个内部类 ThreadLocalMap，ThreadLocalMap 又有个继承于 <strong>WeakReference</strong> 的内部类 Entry  的数组，用来实际存储，Thread 这个类里面有个成员变量 threadLocals 就是 ThreadLocalMap。</p><p>我们在创建 Looper 之后会让 Looper 与当前所在线程关联，就是通过获取当前线程的 ThreadLocalMap，然后再将其放到 Entry 里面。取的时候也是根据当前线程获取其 ThreadLocalMap 再从 Entry 中取。</p><h2 id="jvm：运行时数据分区；类加载过程；GCRoot，垃圾回收算法。–todo"><a href="#jvm：运行时数据分区；类加载过程；GCRoot，垃圾回收算法。–todo" class="headerlink" title="jvm：运行时数据分区；类加载过程；GCRoot，垃圾回收算法。–todo"></a>jvm：运行时数据分区；类加载过程；GCRoot，垃圾回收算法。–todo</h2><h2 id="优化-–todo"><a href="#优化-–todo" class="headerlink" title="优化 –todo"></a>优化 –todo</h2><h2 id="Retrofit-–-doing"><a href="#Retrofit-–-doing" class="headerlink" title="Retrofit – doing"></a>Retrofit – doing</h2><p>核心思想： <code>Retrofit </code>通过动态代理我们定义的 <code>service</code> 接口代理对象，调用其方法时就会转移到<code>InvocationHandler</code> 对象的 <code>invoke</code> 方法中。 </p><ul><li>动态代理获取服务</li><li>对注解参数进行解析封装</li><li>提供转换接口（RxJava、Gson）</li></ul><h2 id="Rxjava-–doing"><a href="#Rxjava-–doing" class="headerlink" title="Rxjava –doing"></a>Rxjava –doing</h2><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p><strong>实现原理</strong><br>LeakCanary 中对内存泄漏的检测基于 WeakReference 和 ReferenceQueue。<br>在构建 WeakReference 对象时传入 ReferenceQueue，当 WeakReference 中传入的对象可以被回收时，会将 WeakReference 对象添加到 ReferenceQueue 中，倘若 WeakReference 中的对象无法被回收时，不会将 WeakReference 对象添加到 ReferenceQueue 中。这样便可以检测到，应该被回收的对象，却没有出现在 ReferenceQueue 中，这些对象就是造成内存泄漏的元凶。<br><strong>检测时机</strong><br>向主线程 MessageQueue 中插入了一个 IdleHandler，IdleHandler 只会在主线程空闲时才会被 Looper 从队列中取出并执行。因此能够有效避免内存检测工作占用 UI 渲染时间。 </p><h2 id="单例、观察者、装饰者，工厂，双亲委托-–todo"><a href="#单例、观察者、装饰者，工厂，双亲委托-–todo" class="headerlink" title="单例、观察者、装饰者，工厂，双亲委托 –todo"></a>单例、观察者、装饰者，工厂，双亲委托 –todo</h2><p>单例：DCL、enum，静态内部类。还有饿汉式。懒汉式的使用场景：占用内存大、延迟初始化</p><h2 id="策略模式和桥接模式的区别-–todo"><a href="#策略模式和桥接模式的区别-–todo" class="headerlink" title="策略模式和桥接模式的区别 –todo"></a>策略模式和桥接模式的区别 –todo</h2><h2 id="插件化和热更新原理-–todo"><a href="#插件化和热更新原理-–todo" class="headerlink" title="插件化和热更新原理 –todo"></a>插件化和热更新原理 –todo</h2><h2 id="Apk打包流程。R文件最终会生成什么文件？aapt的作用是什么？–todo"><a href="#Apk打包流程。R文件最终会生成什么文件？aapt的作用是什么？–todo" class="headerlink" title="Apk打包流程。R文件最终会生成什么文件？aapt的作用是什么？–todo"></a>Apk打包流程。R文件最终会生成什么文件？aapt的作用是什么？–todo</h2></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler 的使用和解析</title>
      <link href="/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/25/Handler-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h2 id="Handler-常用场景"><a href="#Handler-常用场景" class="headerlink" title="Handler 常用场景"></a>Handler 常用场景</h2><p>在 Activity 中定义一个 Handler</p><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mHandler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) {</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> {</span><br><span class="line">        <span class="hljs-keyword">when</span>(msg.what) {</span><br><span class="line">            CODE_GET_USER_INFO -&gt; {</span><br><span class="line">                <span class="hljs-keyword">val</span> user = msg.obj <span class="hljs-keyword">as</span> User</span><br><span class="line">                textViewName.text = user.name</span><br><span class="line">                textViewSite.text = user.site</span><br><span class="line">                imageViewIcon.load(user.icon){</span><br><span class="line">                    transformations(CircleCropTransformation())</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在子线程获取到数据之后通过 Handler 将数据传到 UI 线程进行处理</p><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread {</span><br><span class="line">    <span class="hljs-keyword">val</span> request = Request.Builder()</span><br><span class="line">        .url(<span class="hljs-string">"http://10.0.2.2:8000/user"</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="hljs-keyword">val</span> response = OkHttpClient().newCall(request).execute()</span><br><span class="line">    <span class="hljs-keyword">val</span> result = response.body?.string()</span><br><span class="line">    <span class="hljs-keyword">val</span> user = Gson().fromJson(result, User::<span class="hljs-keyword">class</span>.java)</span><br><span class="line">    Message.obtain().also {</span><br><span class="line">        it.what = CODE_GET_USER_INFO</span><br><span class="line">        it.obj = user</span><br><span class="line">        mHandler.sendMessage(it)</span><br><span class="line">    }</span><br><span class="line">}.start()</span><br></pre></td></tr></tbody></table></figure><p>打开 Handler 源文件，可以看到这样的注释</p><blockquote><p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.</p></blockquote><p>简单概述一下，Handler 两个用途：（1）在未来某个时间点执行事件 （2）跨线程执行事件</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Handler-构造函数"><a href="#Handler-构造函数" class="headerlink" title="Handler 构造函数"></a>Handler 构造函数</h3><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="hljs-keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="hljs-keyword">final</span> Callback mCallback;</span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> mAsynchronous;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-type">boolean</span> async)</span> {</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="title class_">Callback</span> {</span><br><span class="line">    <span class="hljs-type">boolean</span> <span class="title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Handler 的构造函数中初始化了两个重要的成员变量：mLooper 和 mQueue</p><p>我们传人的参数是 Looper.getMainLooper()，代码如下</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Looper sMainLooper;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="title function_">getMainLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (Looper.class) {</span><br><span class="line">        <span class="hljs-keyword">return</span> sMainLooper;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Looper 中的 sMainLooper 又是在哪里初始化的呢？我们看 ActivityThread 这个类中的 main 函数</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">main</span><span class="hljs-params">(String[] args)</span> {</span><br><span class="line">    ...</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="prepareMainLooper"><a href="#prepareMainLooper" class="headerlink" title="prepareMainLooper()"></a>prepareMainLooper()</h3><p> Looper 的 prepareMainLooper 函数以及后续相关函数调用</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    prepare(<span class="hljs-literal">false</span>);</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (Looper.class) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="hljs-string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        }</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="title function_">myLooper</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sThreadLocal.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上调用了 prepare 函数。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    }</span><br><span class="line">    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="hljs-keyword">final</span> Thread mThread;</span><br><span class="line">    </span><br><span class="line"><span class="hljs-keyword">private</span> <span class="title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> {</span><br><span class="line">    mQueue = <span class="hljs-keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，我们可以确定，在 ActivityThread 执行的时候，初始化了 Looper，并且初始化了 Looper 中两个成员变量：消息队列 和 当前线程对象。</p><p>值得注意的是：</p><ol><li>一个线程只能创建一个 Looper，也就是说线程和 Looper 是一一对应的，且它俩是有一定的绑定关系的</li><li>Looper 中有一个 ThreadLocal<looper> 数据结构，用来存储线程和 Looper，维系两者的绑定关系</looper></li></ol><p>我们看一下 ThreadLocal 的相关代码</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> T <span class="title function_">get</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) {</span><br><span class="line">      ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;</span><br><span class="line">            <span class="hljs-keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">set</span><span class="hljs-params">(T value)</span> {</span><br><span class="line">    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)</span><br><span class="line">        map.set(<span class="hljs-built_in">this</span>, value);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> <span class="title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> {</span><br><span class="line">    t.threadLocals = <span class="hljs-keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="hljs-params">(Thread t)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="title class_">ThreadLocalMap</span> {</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">          <span class="hljs-built_in">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">private</span> Entry[] table;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看出，ThreadLocal 中有个 ThreadLocalMap 类，它其实跟 Map 没啥关系。ThreadLocalMap 有个继承于 WeakReference 的内部类 Entry 用来存储 Looper，而 ThreadLocalMap 是赋值给 Thread 的成员变量 threadLocals 的。</p><p>那么也就是通过这种方式实现了一个线程和一个 Looper 的绑定。</p><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><p>初始化的动作做完之后，执行了 Looper.loop()</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">loop</span><span class="hljs-params">()</span> {</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();</span><br><span class="line">    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="hljs-string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (me.mInLoop) {</span><br><span class="line">        Slog.w(TAG, <span class="hljs-string">"Loop again would have the queued messages be executed"</span></span><br><span class="line">                + <span class="hljs-string">" before this one completed."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="hljs-literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) {</span><br><span class="line">        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) {</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> {</span><br><span class="line">    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    ...</span><br><span class="line">    msg.target.dispatchMessage(msg); </span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到 loop 函数中执行了一个死循环，不断的执行 loopOnce 函数。</p><p>在 loopOnce 函数中我们需要注意 2 点：</p><ol><li>Message msg = me.mQueue.next();</li><li>msg.target.dispatchMessage(msg);</li></ol><h4 id="mQueue-next"><a href="#mQueue-next" class="headerlink" title="mQueue.next()"></a>mQueue.next()</h4><p>注意看 next 后面的的注释 <code>might block</code>，这个函数是会阻塞的。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="hljs-params">()</span> {</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) {</span><br><span class="line">        ...</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {</span><br><span class="line">            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;</span><br><span class="line">            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;</span><br><span class="line">            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) {</span><br><span class="line">                <span class="hljs-keyword">do</span> {</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                } <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            }</span><br><span class="line">            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) {</span><br><span class="line">                <span class="hljs-keyword">if</span> (now &lt; msg.when) {</span><br><span class="line">                    ...</span><br><span class="line">                } <span class="hljs-keyword">else</span> {</span><br><span class="line">                    <span class="hljs-comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="hljs-literal">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) {</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    } <span class="hljs-keyword">else</span> {</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    }</span><br><span class="line">                    msg.next = <span class="hljs-literal">null</span>;</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="hljs-keyword">return</span> msg;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ...</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到，next 其实也是执行了一个死循环，不断的取出下一个 Message ，判断其出发时间是否符合，然后将其返回。倘若没有 Message  ，nativePollOnce 会阻塞该函数，直到新的 Message 进入 MessageQueue。</p><h4 id="msg-target-dispatchMessage-msg"><a href="#msg-target-dispatchMessage-msg" class="headerlink" title="msg.target.dispatchMessage(msg)"></a>msg.target.dispatchMessage(msg)</h4><p>取到符合触发时间的消息后，会执行该函数。查看 Message 类我们会发现，它有一个成员变量</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler target;</span><br></pre></td></tr></tbody></table></figure><p>然后执行了 Handler 的 dispatchMessage 函数，传入了当前触发的 Message。</p><p>有 2 点需要理解：</p><ol><li>Message 中的 target 是什么时候初始化的</li><li>Handler 中的 dispatchMessage 做了什么</li></ol><p>回头看最开始简单的使用案例，我们执行了 mHandler.sendMessage(it) 将消息进行发送，进入该函数。</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) {</span><br><span class="line">      delayMillis = <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> {</span><br><span class="line">    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;</span><br><span class="line">    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) {</span><br><span class="line">        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">          <span class="hljs-built_in">this</span> + <span class="hljs-string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="hljs-string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> {</span><br><span class="line">    msg.target = <span class="hljs-built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (mAsynchronous) {</span><br><span class="line">        msg.setAsynchronous(<span class="hljs-literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终调用了 enqueueMessage 将当前 Handler 对象赋值给此次 Message 的 target，并将消息添加到消息队列。</p><p>需要注意的是 MessageQueue 中的 enqueueMessage 函数中，除了将 Message 添加到消息队列，还在某些条件下执行了一个函数 <code>nativeWake()</code>，这个函数就是对应上文中 <code>nativePollOnce()</code> 的，将阻塞唤醒。</p><p>最后我们再看 dispatchMessage</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) {</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    } <span class="hljs-keyword">else</span> {</span><br><span class="line">        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) {</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">handleCallback</span><span class="hljs-params">(Message message)</span> {</span><br><span class="line">    message.callback.run();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实是将消息进行分发消费。这里主要有 3 种消费方式</p><ol><li>Message 中的 callback（其实是一个 Runnable ） 通过 run 进行处理</li><li>Handler 中的 Callback 通过 handleMessage 进行处理</li><li>直接通过 Handler 中的 handleMessage 进行处理</li></ol><p>这也对应 Handler 的三种使用方式。</p><h2 id="Handler-的三种使用方式"><a href="#Handler-的三种使用方式" class="headerlink" title="Handler 的三种使用方式"></a>Handler 的三种使用方式</h2><ul><li>handler.post(Runnable r)</li></ul><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable r)</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="hljs-params">(Runnable r)</span> {</span><br><span class="line">    <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="hljs-keyword">return</span> m;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Handler(Looper looper, Callback callback)</li></ul><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="title function_">Handler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Looper looper, <span class="hljs-meta">@Nullable</span> Callback callback)</span> {</span><br><span class="line">    <span class="hljs-built_in">this</span>(looper, callback, <span class="hljs-literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>文中常用使用场景</li></ul><figure class="highlight kotlin hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mHandler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) {</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 Handler 大致可以分为 3 个阶段去理解</p><ol><li>初始化阶段<br> 在创建 Handler 对象的同时，会初始化 Looper  和 Looper 中的 MessageQueue。 Looper 的初始化包括对象创建和 loop() 调用。</li></ol><ul><li>Looper 的初始化涉及到 Handler 所工作的线程，井且会将 Looper 对象存储在 Threadlocal 中，再赋值给该线程的成员变量。这样线程和 Looper 就建立了绑定关系，且一个线程最多只能创建一个Looper，初始化多次会拋出异常。值得注意的是在 UI 线程是不需要调用 Looper.prepare() 去初始化的，因为在ActivityThread 的 main 函数，也就是APP进程启动入口里面，已经执行了 Looper.prepareMainLooper() 和 Looper.loop()。</li><li>loop() 调用其实就是执行了一个死循环，然后从 MessageQueue 中取出 Message， 取到了就发给 Handler 去处理，取不到就阻塞。</li></ul><ol start="2"><li>消息发送<br> 通过 Handler 将 Message 加入 MessageQueue。</li></ol><ul><li>这里首先会将 Handler 与 Message 进行绑定，以便后续 Message 取出后交给Handler 进行处理</li><li>按照 Message 的执行时间将其插入到 MessageQueue 中</li></ul><ol start="3"><li>消息分发<br> 在loop()循环中检查到符合执行时间的 Message 后，这里对应 Handler 的不同构造方法和消息发送方式有 3种分发情况。</li></ol><ul><li><p>handler.post(Runnable n)，优先判断 Message 中是否有 Runnable对象，有的话执行其 run 方法</p></li><li><p>Handler(Looper looper, Callback callback)，其次再判断是否在创建 Handler 的时候传入了 Callback，如果有，执行其 handleMessage 方法</p></li><li><p>上述两种都不满足的话，执行 Handler 自身的 handleMessage 方法</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo修改主题</title>
      <link href="/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/"/>
      <url>/2022/08/20/Hexo%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h3 id="1-挑选自己喜欢的主题"><a href="#1-挑选自己喜欢的主题" class="headerlink" title="1. 挑选自己喜欢的主题"></a>1. 挑选自己喜欢的主题</h3><p>进入 <a href="https://hexo.io/themes/">hexo主题网站</a>，挑选自己喜欢的主题，点击预览图进入效果展示模版网站，点击主题名称进入主题 GitHub 仓库。</p><h3 id="2-下载主题"><a href="#2-下载主题" class="headerlink" title="2. 下载主题"></a>2. 下载主题</h3><p>执行clone命令，下载到对应的文件夹内。一般主题仓库都有相关说明。</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos</span><br></pre></td></tr></tbody></table></figure><p>如果该项目有其他依赖库，需要一并下载。</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs --save-d</span><br><span class="line">npm install hexo-renderer-sass --save</span><br></pre></td></tr></tbody></table></figure><h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h3><p>打开博客源文件根目录下  <code>_config.yml</code>，修改如下：</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: minos</span><br></pre></td></tr></tbody></table></figure><p>其他配置可以参考主题仓库中描述进行修改。</p><h3 id="4-保存和部署"><a href="#4-保存和部署" class="headerlink" title="4. 保存和部署"></a>4. 保存和部署</h3><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 构建博客</title>
      <link href="/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/08/20/Hexo-GitHub-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><span id="more"></span><h4 id="1-下载安装-Node"><a href="#1-下载安装-Node" class="headerlink" title="1. 下载安装 Node"></a>1. 下载安装 Node</h4><p><a href="https://nodejs.org/en/">Node官网</a>，一步步安装即可</p><h4 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h4><h4 id="3-申请-GitHub（用户名为-username-），配置-SSH-Keys"><a href="#3-申请-GitHub（用户名为-username-），配置-SSH-Keys" class="headerlink" title="3. 申请 GitHub（用户名为 username ），配置 SSH Keys"></a>3. 申请 GitHub（用户名为 username ），配置 SSH Keys</h4><p>创建仓库，名字固定：<code>username.github.io</code></p><h4 id="4-安装-HEXO"><a href="#4-安装-HEXO" class="headerlink" title="4. 安装 HEXO"></a>4. 安装 HEXO</h4><p>打开<code>Git Bash</code>, 执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></tbody></table></figure><p>如果不行，执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><p>然后安装，执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></tbody></table></figure><h4 id="5-创建一个文件夹-blog-，在文件夹内-Shift-右键打开命令窗口"><a href="#5-创建一个文件夹-blog-，在文件夹内-Shift-右键打开命令窗口" class="headerlink" title="5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口"></a>5. 创建一个文件夹 blog ，在文件夹内 Shift + 右键打开命令窗口</h4><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></tbody></table></figure><p>再执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></tbody></table></figure><p><em>（hexo g 也可以）</em></p><h4 id="6-启动-HEXO"><a href="#6-启动-HEXO" class="headerlink" title="6. 启动 HEXO"></a>6. 启动 HEXO</h4><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure><p>浏览器输入 <code>http://localhost:4000</code> 即可打开</p><h4 id="7-修改-blog-下-config-yml"><a href="#7-修改-blog-下-config-yml" class="headerlink" title="7. 修改 blog 下 _config.yml"></a>7. 修改 blog 下 _config.yml</h4><p>最下方修改为</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: git</span><br><span class="line">repository: https://github.com/username/username.github.io</span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line">-其他配置自主修改</span><br></pre></td></tr></tbody></table></figure><p>然后</p><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>执行</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>现在查看 github 仓库，你会发现已经有很多文件了<br>在浏览器打开 <code>https://username.github.io/</code> 即可访问</p><h4 id="8-常用命令"><a href="#8-常用命令" class="headerlink" title="8. 常用命令"></a>8. 常用命令</h4><p>部署</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>其他</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new "postName" #新建文章</span><br><span class="line">hexo new page "pageName" #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help  #查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></tbody></table></figure><p>case:创建一片博文</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. hexo new "title"</span><br><span class="line">2. \blog\source\_posts下会生成title.md文件，用MD编辑器打开，编写内容</span><br><span class="line">3. hexo generate</span><br><span class="line">4. hexo deploy</span><br><span class="line">5. 完成，重新访问blog即可看到刚才编辑的文章</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
